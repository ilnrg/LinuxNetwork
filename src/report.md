# **ОТЧЁТ**

## **Part 1. Инструмент ipcalc**
- Поднимаем виртуальную машину `ws1`:\
![команда](img/1_00.png)
- Для выполнения задания устанавливаем и используем утилиту `ipcalc`:\
![команда](img/1_01.png)
### **1.1. Сети и маски**
1) Определяем адрес сети `192.167.38.54/13`:\
	![команда](img/1_02.png)\
	Адрес - `192.167.38.54`
2) Перевод маски `255.255.255.0` в префиксную и двоичную запись:\
	![команда](img/1_03.png)\
	Префиксная запись - `/24`\
	Двоичная запись - `11111111.11111111.11111111.00000000`
- Перевод маски `/15` в обычную и двоичную запись:\
	![команда](img/1_04.png)\
	Обычная запись - `255.254.0.0`\
	Двоичная запись - `11111111.11111110.00000000.00000000`
- Перевод маски `11111111.11111111.11111111.11110000` в обычную и префиксную запись:\
	![команда](img/1_05.png)\
	Для использования `ipcalc` с маской в двоичном виде берём любой адрес (в нашем случае - `0.0.0.0`) и префикс `/28` - количество единиц в исходной маске\
	Обычная запись - `255.255.255.240`\
	Префиксная запись - `/28`
3) Минимальный и максимальный хост в сети `12.167.38.4` при масках:
- `/8`:\
	![команда](img/1_06.png)\
	HostMin - `12.0.0.1`\
	HostMax - `12.255.255.254`
- `11111111.11111111.00000000.00000000 (/16)`:\
	![команда](img/1_07.png)\
	HostMin - `12.167.0.1`\
	HostMax - `12.167.255.254`
- `255.255.254.0`:\
	![команда](img/1_08.png)\
	HostMin - `12.167.38.1`\
	HostMax - `12.167.39.254`
- `/4`:\
	![команда](img/1_09.png)\
	HostMin - `0.0.0.1`\
	HostMax - `15.255.255.254`
### **1.2. localhost**
- Адреса `localhost` находятся в диапазоне `127.0.0.1 — 127.255.255.254`. Соответственно обратиться можно к приложениям с IP: `127.0.0.2, 127.1.0.1`, а с IP: `194.34.23.100, 128.0.0.1` - нет
- Используя утилиту `ipcalc` это можно определить по наличию или отсутствию записи `loopback` в строке `Hosts/Net`:
	- `194.34.23.100` - нет:\
	![команда](img/1_10.png)
	- `127.0.0.2` - да:\
	![команда](img/1_11.png)
	- `127.1.0.1` - да:\
	![команда](img/1_12.png)
	- `128.0.0.1` - нет:\
	![команда](img/1_13.png)
### **1.3. Диапазоны и сегменты сетей**
1) Частные адреса находятся в трёх диапазонах:\
	`10.0.0.0 – 10.255.255.255`\
	`172.16.0.0 – 172.31.255.255`\
	`192.168.0.0 – 192.168.255.255`
- Соответственно адреса: `10.0.0.45`, `192.168.4.2`, `172.20.250.4`, `172.16.255.255`, `10.10.10.10` являются частными, а адреса: `134.43.0.2`, `172.0.2.1`, `192.172.0.1`, `172.68.0.2`, `192.169.168.1`  - публичными
- Используя утилиту `ipcalc` это можно определить по наличию или отсутствию записи `Private Internet` в строке `Hosts/Net`:
	- `10.0.0.45` - частный:\
	![команда](img/1_14.png)
	- `134.43.0.2` - публичный:\
	![команда](img/1_15.png)
	- `192.168.4.2` - частный:\
	![команда](img/1_16.png)
	- `172.20.250.4` - частный:\
	![команда](img/1_17.png)
	- `172.0.2.1` - публичный:\
	![команда](img/1_18.png)
	- `192.172.0.1` - публичный:\
	![команда](img/1_19.png)
	- `172.68.0.2` - публичный:\
	![команда](img/1_20.png)
	- `172.16.255.255` - частный:\
	![команда](img/1_21.png)
	- `10.10.10.10` - частный:\
	![команда](img/1_22.png)
	- `192.169.168.1` - публичный:\
	![команда](img/1_23.png)
2) Чтобы определить, какие IP-адреса шлюза возможны у сети `10.10.0.0/18`, нам нужны строки `HostMin` и `HostMax`:\
	![команда](img/1_24.png)
- Соответственно, из перечисленных IP-адресов у сети `10.10.0.0/18` возможны адреса, которые входят в диапазон `10.10.0.1 - 10.10.63.254`, а именно: `10.10.0.2`, `10.10.10.10`, `10.10.1.255`

## **Part 2. Статическая маршрутизация между двумя машинами**
- Поднимаем вторую виртуальную машину `ws2`:\
![команда](img/2_01.png)
- Существующие сетевые интерфейсы:
	- **ws1:**\
	![команда](img/2_02.png)
	- **ws2:**\
	![команда](img/2_03.png)
- Описание сетевых интерфейсов:
	- На каждой виртуальной машине открываем файл через `sudo vim /etc/netplan/00-installer-config.yaml` и добавляем необходимые настройки:
		- **ws1:**\
		![команда](img/2_04.png)
		- **ws2:**\
		![команда](img/2_05.png)
	- Сохраняем через `:wq`. Проверяем изменения:
		- **ws1:**\
		![команда](img/2_06.png)
		- **ws2:**\
		![команда](img/2_07.png)
	- Перезапускаем сервис сети:
		- **ws1:**\
		![команда](img/2_08.png)
		- **ws2:**\
		![команда](img/2_09.png)
### **2.1. Добавление статического маршрута вручную**
- Командой вида `ip r add` добавляем статический маршрут от одной машины до другой и обратно:
	- **ws1:**\
	![команда](img/2_10.png)
	- **ws2:**\
	![команда](img/2_11.png)
- Пингуем соединение между машинами:
	- **ws1:**\
	![команда](img/2_12.png)
	- **ws2:**\
	![команда](img/2_13.png)
### **2.2. Добавление статического маршрута с сохранением**
- Перезапускаем машины - `reboot`
- На каждой виртуальной машине открываем файл через `sudo vim /etc/netplan/00-installer-config.yaml` и добавляем маршруты:
	- **ws1:**\
	![команда](img/2_14.png)
	- **ws2:**\
	![команда](img/2_15.png)
- Сохраняем через `:wq`. Проверяем изменения:
	- **ws1:**\
	![команда](img/2_16.png)
	- **ws2:**\
	![команда](img/2_17.png)
- Перезапускаем сервис сети:
	- **ws1:**\
	![команда](img/2_08.png)
	- **ws2:**\
	![команда](img/2_09.png)
- Пингуем соединение между машинами:
	- **ws1:**\
	![команда](img/2_18.png)
	- **ws2:**\
	![команда](img/2_19.png)

## **Part 3. Утилита iperf3**
### **3.1. Скорость соединения**
- Перевод:
	- 8 Mbps = 1 MB/s
	- 100 MB/s = 100000 Kbps
	- 1 Gbps = 1000 Mbps
### **3.2. Утилита iperf3**
- Устанавливаем утилиту `iperf3` - `sudo apt install iperf3`
- Для использования `iperf3` необходимо, чтобы одна машина выступала в качестве сервера, а другая - в качестве клиента
- Роль сервера будет выполнять `ws1`, для этого на машине запускаем `iperf3 -s`:\
![команда](img/3_1.png)
- На машине `ws2` (клиент) запускаем `iperf3 -c 192.168.100.10`:\
![команда](img/3_2.png)

## **Part 4. Сетевой экран**
### **4.1. Утилита iptables**
- Создаём файл `firewall.sh` на каждой машине и добавляем правила:
	- **ws1:**\
		![команда](img/4_01.png)\
		![команда](img/4_02.png)
	- **ws2:**\
		![команда](img/4_03.png)\
		![команда](img/4_04.png)
- Сначала на каждой машине открываем доступ для `порта 22 (ssh)` и `порта 80 (http)`. Затем добавляем правила о блокировке (`REJECT`) и разрешении (`ACCEPT`) `echo reply` на машине `ws1`, на `ws2` делаем то же самое, но в обратном порядке
- Сохраняем через `:wq`
- Запускаем файлы на обеих машинах:
	- **ws1:**\
		![команда](img/4_05.png)
	- **ws2:**\
		![команда](img/4_06.png)
- Суть правил в `firewall.sh` заключается в том, что применяется первое подходящее правило пока не встретится запрет. В первом случае, когда мы сначала запретили `echo reply`, а затем разрешили, будем применено правило о блокировке (`REJECT`), а правило о разрешении (`ACCEPT`) будет проигнорировано. Во втором же случае - наоборот: оба правила применятся
### **4.2. Утилита nmap**
- Устанавливаем утилиту `nmap` - `sudo apt install nmap`
- Пингуем обе машины и ищем машину, которая не пингуется:
	- **ws1:**\
		![команда](img/4_07.png)
	- **ws2:**\
		![команда](img/4_08.png)
- Видим, что пинг с `ws2` на `ws1` не проходит. Значит `ws1` не пингуется
- Запускаем `nmap` и видим, что хост машины запущен:\
![команда](img/4_09.png)
- Сохраняем дампы образов виртуальных машин:\
![команда](img/4_10.png)

## **Part 5. Статическая маршрутизация сети**
- Поднимаем 5 виртуальных машин:\
![команда](img/5_01.png)
### **5.1. Настройка адресов машин**
- Настраиваем конфигурации машин:
	- **ws11:**\
		![команда](img/5_02.png)
	- **ws21:**\
		![команда](img/5_03.png)
	- **ws22:**\
		![команда](img/5_04.png)
	- **r1:**\
		![команда](img/5_05.png)
	- **r2:**\
		![команда](img/5_06.png)
- Перезапускаем сервис сети и проверяем, что адрес машины задан верно:
	- **ws11:**\
		![команда](img/5_07.png)
	- **ws21:**\
		![команда](img/5_08.png)
	- **ws22:**\
		![команда](img/5_09.png)
	- **r1:**\
		![команда](img/5_10.png)
	- **r2:**\
		![команда](img/5_11.png)
- Пингуем `ws22` с `ws21`:\
![команда](img/5_12.png)
- Пингуем `r1` с `ws11`:\
![команда](img/5_13.png)
### **5.2. Включение переадресации IP-адресов**
- Включаем переадресацию IP:
	- **r1:**\
		![команда](img/5_14.png)
	- **r2:**\
		![команда](img/5_15.png)
- Изменяем файл `/etc/sysctl.conf`:
	- **r1:**\
		![команда](img/5_16.png)
	- **r2:**\
		![команда](img/5_17.png)
### **5.3. Установка маршрута по-умолчанию**
- Настраиваем маршрут по-умолчанию для рабочих станций:
	- **ws11:**\
		![команда](img/5_18.png)
	- **ws21:**\
		![команда](img/5_19.png)
	- **ws22:**\
		![команда](img/5_20.png)
- Ищем маршрут в таблице маршрутизации:
	- **ws11:**\
		![команда](img/5_21.png)
	- **ws21:**\
		![команда](img/5_22.png)
	- **ws22:**\
		![команда](img/5_23.png)
- Перед пингом `r2` с `ws11` нужно установить связь между роутерами:\
![команда](img/5_35.png)\
![команда](img/5_36.png)
- Теперь пингуем `r2` с `ws11`:\
![команда](img/5_24.png)
- Проверяем, что пинг доходит:\
![команда](img/5_25.png)
### **5.4. Добавление статических маршрутов**
- Добавляем в роутеры статические маршруты:
	- **r1:**\
		![команда](img/5_26.png)
	- **r2:**\
		![команда](img/5_27.png)
- Проверяем маршруты:
	- **r1:**\
		![команда](img/5_28.png)
	- **r2:**\
		![команда](img/5_29.png)
- Запускаем команды `ip r list 10.10.0.0/[маска сети]` и `ip r list 0.0.0.0/0`:\
	![команда](img/5_30.png)
- Маршрут по умолчанию используется тогда, когда нет другого заданного маршрута, т.е. у такого маршрута наименьший приоритет. Т.к. мы задали правило для сети `10.10.0.0`, то он будет идти по заданному маршруту
### **5.5. Построение списка маршрутизаторов**
- Запускаем на `r1` команду дампа:\
![команда](img/5_31.png)
- При помощи утилиты `traceroute` строим список маршрутизаторов от `ws11` до `ws21`:\
![команда](img/5_32.png)
- `traceroute` предоставляет информацию о пути пакета данных из одной точки сети на конкретный IP-сервер. Когда данные передаются между двумя точками, они должны проходить через несколько устройств (в нашем случае - `r1` и `r2`). Утилита отправляет 3 UDP-пакета на определенный порт целевого хоста и ожидает ответа о недоступности этого порта. Первый пакет отправляется с TTL = 1, второй с TTL = 2 и так далее, пока запрос не попадет адресату. При TTL = 1 traceroute, получая ответ от первого маршрутизатора, определяет его IP-адрес и время, затраченное на обработку пакета. После этого TTL увеличивается на единицу для определения следующего маршрутизатора, и так далее до момента попадания пакета на целевой хост. Утилита использует указанный ей IP-адрес, и порт 34434 по умолчанию. Целевой хост принимает пакет, и отправляет сообщение о недоступности порта 34434 (так как в большинстве случаев он не используется каким-либо сервисом и закрыт). В итоге отслеживается вся цепочка следования пакета, которая завершается ответом от целевого хоста
### **5.6. Использование протокола ICMP при маршрутизации**
- Запускаем на `r1` перехват сетевого трафика:\
![команда](img/5_33.png)
- Пингуем с `ws11` несуществующий IP:\
![команда](img/5_34.png)
- Вывод `tcpdump`:\
![команда](img/5_37.png)
- Сохраняем дампы виртуальных машин:\
![команда](img/5_38.png)

## **Part 6. Динамическая настройка IP с помощью DHCP**
- Перед настройкой устанавливаем службу DHCP - `sudo apt install isc-dhcp-server`
- Настраиваем конфигурацию службы DHCP для машины `r2`:\
![команда](img/6_01.png)
- В файле `resolv.conf` прописываем `nameserver 8.8.8.8`:\
![команда](img/6_02.png)
- Перезагружаем службу DHCP и проверяем статус:\
![команда](img/6_03.png)
- Чтобы машина `ws21` получила новый адрес от `r2` нужно внести изменения в конфигурационный файл:\
![команда](img/6_04.png)
- Перезагружаем `ws21` и проверяем, что адрес дошёл:\
![команда](img/6_05.png)\
![команда](img/6_06.png)
- Пингуем `ws22` с `ws21`:\
![команда](img/6_07.png)
- Добавляем MAC-адрес у `ws11`:\
![команда](img/6_08.png)\
![команда](img/6_09.png)
- Делаем аналогичные `r2` настройки у `r1`, но с жесткой привязкой к MAC-адресу и перезапускаем сервер:\
![команда](img/6_10.png)\
![команда](img/6_11.png)\
![команда](img/6_12.png)
- Перезагружаем `ws11` и проверяем адрес:\
![команда](img/6_13.png)\
![команда](img/6_14.png)
- Пингуем `ws21` с `ws11`:\
![команда](img/6_15.png)
- Смотрим текущий IP-адрес `ws21`:\
![команда](img/6_16.png)
- Перед обновлением IP-адреса удаляем текущий адрес и проверяем, что адреса нет:\
![команда](img/6_17.png)
- Запрашиваем новый IP-адрес и проверяем:\
![команда](img/6_18.png)
- Утилита `dhclient` используется для управления адресом. Флаг `-r` освобождает текущий адрес, а команда без флага задаёт новый IP-адрес
- Сохраняем дампы виртуальных машин:\
![команда](img/6_19.png)

## **Part 7. NAT**
- Изменяем файл `/etc/apache2/ports.conf`:
	- **ws22:**\
		![команда](img/7_01.png)
	- **r1:**\
		![команда](img/7_02.png)
- Запускаем сервер `Apache`:
	- **ws22:**\
		![команда](img/7_03.png)
	- **r1:**\
		![команда](img/7_04.png)
- Создаём на `r2` файл `firewall.sh` и добавляем в него правила:\
![команда](img/7_05.png)
- Запускаем фаерволл:\
![команда](img/7_06.png)
- Проверяем соединение между `ws22` и `r1`. Видим, что соединение не проходит:\
![команда](img/7_07.png)
- Добавляем новое правило в `firewall.sh`:\
![команда](img/7_08.png)
- Запускаем фаерволл:\
![команда](img/7_09.png)
- Проверяем соединение между `ws22` и `r1`. Видим, что в этот раз соединение проходит:\
![команда](img/7_10.png)
- Добавляем ещё два правила в `firewall.sh`:\
![команда](img/7_11.png)
- Запускаем фаерволл:\
![команда](img/7_12.png)
- На `ws22` проверяем соединение по TCP для SNAT:\
![команда](img/7_13.png)
- На `r1` проверяем соединение по TCP для DNAT:\
![команда](img/7_14.png)
- Сохраняем дампы виртуальных машин:\
![команда](img/7_15.png)

## **Part 8. Дополнительно. Знакомство с SSH Tunnels**
- Запускаем `firewall.sh` на `r2`:\
![команда](img/8_1.png)\
![команда](img/8_2.png)
- Запускаем сервер Apache на `ws22` и изменяем файл `/etc/apache2/ports.conf`:\
![команда](img/8_3.png)\
![команда](img/8_4.png)
- Используем `Local TCP forwarding (-L)`, чтобы с `ws21` получить доступ к веб-серверу на `ws22`:\
![команда](img/8_5.png)
- Проверяем, что соединение сработало:\
![команда](img/8_6.png)
- Используем `Remote TCP forwarding (-R)`, чтобы c `ws11` получить доступ к веб-серверу на `ws22`:\
![команда](img/8_7.png)
- Проверяем, что соединение сработало:\
![команда](img/8_8.png)
- Сохраняем дампы виртуальных машин:\
![команда](img/8_9.png)